import * as btn from './btn.js';

class Calculator {
	constructor() {
		this.constants = {
			pi: Math.PI,
			e: Math.E,
			sq2: Math.SQRT2,
		};
		this.display = btn.display;
		this.currentValue = '';
		this.previousValue = '';
		this.operator = '';
		this.isPoweredOn = true;
		this.cursorIndex = 0;
	}

	// FUNCTIONALITY //////////////////////////////////////////

	performOperation() {
		try {
			if (btn.singleOperations.includes(this.operator)) {
				this.currentValue = this.applySingleOperation(
					this.operator,
					this.currentValue.replace(this.operator, '')
				);
				this.updateDisplay(this.currentValue);
			} else {
				let [num1, num2, num3] = this.currentValue
					.split(this.operator)
					.map((value) => value.trim());

				[num1, num2, num3] = [num1, num2, num3].map((num) => {
					return btn.constants[num] !== undefined ? btn.constants[num] : parseFloat(num);
				});

				if (isNaN(num1) || isNaN(num2)) {
					if ((this.operator === '-' || this.operator === '+') && !num2)
						throw new Error('Invalid a');
					else if (this.operator === '-') [num1, num2] = [-num2, num3];
					else if (this.operator === '+') [num1, num2] = [num2, num3];
					else throw new Error('Invalid b');
				}

				this.currentValue = this.applyBinaryOperation(this.operator, num1, num2);
				this.updateDisplay(this.currentValue);
			}
		} catch (err) {
			this.handleError(err);
		}
	}

	applySingleOperation(operator, value) {
		value = parseFloat(value);
		switch (operator) {
			case '√':
				return this.squareRoot(value);
			case '1/':
				return this.inverse(value);
			case 'exp':
				return this.exponent(value);
			case '^-':
				return this.negativePower(value);
			case '^2':
				return this.square(value);
			case 'log_2':
				return this.logBase2(value);
			case 'ln':
				return this.naturalLog(value);
			case 'cos':
				return this.cosine(value);
			case 'sin':
				return this.sine(value);
			case 'tan':
				return this.tangent(value);
			case 'log':
				return this.logarithm(value);
			case '3_√':
				return this.cubeRoot(value);
			case '!':
				return this.factorial(value);
			default:
				throw new Error('Unknown Operation');
		}
	}

	applyBinaryOperation(operator, num1, num2) {
		switch (operator) {
			case '+':
				return this.add(num1, num2);
			case '-':
				return this.subtract(num1, num2);
			case 'x':
				return this.multiply(num1, num2);
			case '/':
				return this.divide(num1, num2);
			case 'x10^':
				return this.powerOfTen(num1, num2);
			case '^':
				return this.power(num1, num2);
			case 'C':
				return this.combination(num1, num2);
			case 'P':
				return this.permutation(num1, num2);
			case '%':
				return this.modulus(num1, num2);
			default:
				throw new Error('Unknown Operation');
		}
	}

	append(value) {
		if (!this.isPoweredOn) return;
		value = value.toString();
		this.currentValue += value;
		this.updateDisplay(this.currentValue);

		if (btn.operations.includes(value)) {
			if (this.operator && this.operator !== '+' && this.operator !== '-') {
				this.calculate();
				return;
			} else this.operator = value;
		}
		this.cursorIndex += value.length;
	}

	powerOff() {
		this.reset();
		this.isPoweredOn = false;
		this.display.disabled = true;
		this.display.value = '';
	}

	powerOn() {
		this.reset();
		this.isPoweredOn = true;
		this.updateDisplay('0');
		this.display.disabled = false;
	}

	reset() {
		this.currentValue = '';
		this.previousValue = '';
		this.operator = '';
		this.cursorIndex = 0;
	}

	calculate() {
		if (!this.currentValue || !this.operator) return;
		this.performOperation();
		this.previousValue = this.currentValue;
		this.currentValue = '';
		this.operator = '';
		// put cursor at the end of the display
		this.cursorIndex = this.currentValue.length;
	}

	handleError(err) {
		this.updateDisplay('ERROR');
		console.error(err.message);
	}

	// DISPLAY //////////////////////////////////////////


	clear() {
		this.currentValue = '';
		this.operator = '';
		this.updateDisplay('0');
	}

	updateDisplay(content) {
		this.display.value = content;
	}

	left() {
		if (this.cursorIndex === 0) return;
		this.cursorIndex--;

		console.log(`cursor` + this.cursorIndex);
		console.log(`length` + this.display.value.length);
	}

	right() {
		if (this.cursorIndex === this.display.value.length) return;
		this.cursorIndex++;

		console.log(`cursor` + this.cursorIndex);
		console.log(`length` + this.display.value.length);
	}

	delete() {
		if (!this.display.value) return;
		if (this.display.value.length === 0 || this.display.value.length === 1) {
			this.currentValue = '';
			this.updateDisplay('0');
			this.cursorIndex = 0;
			return;
		}
		this.currentValue =
			this.currentValue.slice(0, this.cursorIndex - 1) + this.currentValue.slice(this.cursorIndex);
		this.cursorIndex--;
		this.updateDisplay(this.currentValue || '0');
	}

	// Math Operations //////////////////////////////////////////

	add(num1 = this.previousValue, num2) {
		if (isNaN(num1)) return num2;
		return num1 + num2;
	}

	subtract(num1 = this.previousValue, num2) {
		if (isNaN(num1)) return -num2;
		return num1 - num2;
	}

	multiply(num1, num2) {
		return num1 * num2;
	}

	divide(num1, num2) {
		if (num2 === 0) throw new Error('Cannot divide by zero');
		return num1 / num2;
	}

	modulus(num1, num2) {
		console.log(num1, num2);

		return num1 % num2;
	}

	power(num1, exponent) {
		return Math.pow(num1, exponent);
	}

	squareRoot(num) {
		if (num < 0) throw new Error('Invalid input for square root');
		return Math.sqrt(num);
	}

	cubeRoot(num) {
		return Math.cbrt(num);
	}

	square(num) {
		return this.power(num, 2);
	}

	negativePower(num) {
		return this.power(num, -1);
	}

	inverse(num) {
		return 1 / num;
	}

	logarithm(num) {
		console.log(num);

		return Math.log10(num);
	}

	logBase2(num) {
		return Math.log2(num);
	}

	naturalLog(num) {
		console.log(num);

		return Math.log(num);
	}

	sine(num) {
		return Math.sin(num);
	}

	cosine(num) {
		return Math.cos(num);
	}

	tangent(num) {
		return Math.tan(num);
	}

	powerOfTen(num1, num2) {
		return num1 * Math.pow(10, num2);
	}

	abs(num) {
		return Math.abs(num);
	}

	ans() {
		console.log(this.previousValue);
		this.previousValue ? this.append(this.previousValue) : void 0;
		this.cursorIndex += this.currentValue.length;
	}

	exponent(num) {
		return Math.exp(num);
	}

	// Probability //////////////////////////////////////////

	permutation(n, r) {
		return this.factorial(n) / this.factorial(n - r);
	}

	combination(n, r) {
		return this.factorial(n) / (this.factorial(r) * this.factorial(n - r));
	}

	factorial(num) {
		if (num < 0) throw new Error('Invalid input for factorial');
		if (num === 0) return 1;
		return Array.from({ length: num }, (_, i) => i + 1).reduce((a, b) => a * b, 1);
	}
}

export default Calculator;